import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

class Node {
  int i, j;

  public Node(int i, int j) {
    this.i = i;
    this.j = j;
  }

  @Override
  public String toString() {
    return "(" + i + " " + j + ")";
  }

  @Override
  public int hashCode() {
    int result = 31;
    result = 17 * result + i;
    result = 17 * result + j;
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    final Node other = (Node) obj;
    return other.j == j && other.i == i;
  }
}

public class FloodRelief {
  int N;
  int M;
  String[] heights;
  Map<Node, Integer> incidentMatrix;

  public int minimumPumps(String[] heights) {
    N = heights.length;
    M = heights[0].length();

    this.heights = heights;
    incidentMatrix = new HashMap<Node, Integer>();

    for (int i = 0; i < N; i++)
      for (int j = 0; j < M; j++)
        bfs(i, j);

    final List<Integer> values = new ArrayList<Integer>(incidentMatrix.values());
    Collections.sort(values, Collections.reverseOrder());
    int count = 0;
    int incidenceSum = 0;

    for (final Integer s : values) {
      if (incidenceSum >= N * M)
        break;
      incidenceSum += s;
      count += 1;
    }
    return count;
  }

  private void bfs(int i, int j) {
    final Queue<Node> q = new LinkedList<Node>();
    final boolean[][] cache = new boolean[N][M];
    cache[i][j] = true;
    q.add(new Node(i, j));
    new Node(i, j);

    while (!q.isEmpty()) {
      final Node node = q.poll();
      updateMap(incidentMatrix, node);

      for (final Node neighbor : neighbors(node)) {
        if (cache[neighbor.i][neighbor.j])
          continue;
        q.offer(neighbor);
        cache[neighbor.i][neighbor.j] = true;
      }
    }
  }

  private void updateMap(Map<Node, Integer> map, Node node) {
    if (map.containsKey(node))
      map.put(node, map.get(node) + 1);
    else
      map.put(node, 1);
  }

  private List<Node> neighbors(Node node) {
    final List<Node> neighbors = new ArrayList<Node>();
    final int i = node.i, j = node.j;

    if (withinBounds(i - 1, j) && satisfiesCondition(i, j, i - 1, j))
      neighbors.add(new Node(i - 1, j));

    if (withinBounds(i, j - 1) && satisfiesCondition(i, j, i, j - 1))
      neighbors.add(new Node(i, j - 1));

    if (withinBounds(i, j + 1) && satisfiesCondition(i, j, i, j + 1))
      neighbors.add(new Node(i, j + 1));

    if (withinBounds(i + 1, j) && satisfiesCondition(i, j, i + 1, j))
      neighbors.add(new Node(i + 1, j));

    return neighbors;
  }

  private boolean satisfiesCondition(int i, int j, int ni, int nj) {
    return  heights[i].charAt(j) >= heights[ni].charAt(nj);
  }

  private boolean withinBounds(int i, int j) {
    return i < N && i >= 0 && j < M && j >= 0;
  }

  // BEGIN KAWIGIEDIT TESTING
  // Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
  private static boolean KawigiEdit_RunTest(int testNum, String[] p0, boolean hasAnswer, int p1) {
    System.out.print("Test " + testNum + ": [" + "{");
    for (int i = 0; p0.length > i; ++i) {
      if (i > 0) {
        System.out.print(",");
      }
      System.out.print("\"" + p0[i] + "\"");
    }
    System.out.print("}");
    System.out.println("]");
    FloodRelief obj;
    int answer;
    obj = new FloodRelief();
    final long startTime = System.currentTimeMillis();
    answer = obj.minimumPumps(p0);
    final long endTime = System.currentTimeMillis();
    boolean res;
    res = true;
    System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
    if (hasAnswer) {
      System.out.println("Desired answer:");
      System.out.println("\t" + p1);
    }
    System.out.println("Your answer:");
    System.out.println("\t" + answer);
    if (hasAnswer) {
      res = answer == p1;
    }
    if (!res) {
      System.out.println("DOESN'T MATCH!!!!");
    } else if ((endTime - startTime) / 1000.0 >= 2) {
      System.out.println("FAIL the timeout");
      res = false;
    } else if (hasAnswer) {
      System.out.println("Match :-)");
    } else {
      System.out.println("OK, but is it right?");
    }
    System.out.println("");
    return res;
  }

  public static void main(String[] args) {
    boolean all_right;
    all_right = true;

    String[] p0;
    int p1;

    // ----- test 0 -----
    p0 =
        new String[] {
            "zzzzzzzzzzzzzzzzz",
            "ccccccczzzcccczzz",
            "zzzczzzzzczzzzczz",
            "zzzczzzzzczzzzzzz",
            "zzzczzzzzczzzzzzz",
            "zzzczzzzzczzzzczz",
            "zzzczzzzzzcccczzz",
            "zzzzzzzzzzzzzzzzz",
            "zddddzddddzzdzzzd",
            "zdzzdzdzzzdzddzdd",
            "zdzzzzdzzzdzdzdzd",
            "zddddzddddzzdzzzd",
            "zzzzdzdzzzdzdzzzd",
            "zdzzdzdzzzdzdzzzd",
            "zddddzdzzzdzdzzzd" };

    p1 = 13;
    all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
    // ------------------

    // ----- test 1 -----
    p0 = new String[] { "cbabcbabc", "cbabcbabc", "cbabcbabc", "cbabcbabc" };
    p1 = 2;
    all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
    // ------------------

    // ----- test 2 -----
    p0 =
        new String[] {
            "ccccccccccc",
            "caaaaaaaaac",
            "caaaaaaaaac",
            "caazpppzaac",
            "caapdddpaac",
            "caapdddpaac",
            "caapdddpaac",
            "caazpppzaac",
            "caaaaaaaaac",
            "caaaaaaaaac",
            "ccccccccccc" };
    p1 = 2;
    all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
    // ------------------

    // ----- test 3 -----
    p0 = new String[] { "ab", "ba" };
    p1 = 2;
    all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
    // ------------------

    if (all_right) {
      System.out.println("You're a stud (at least on the example cases)!");
    } else {
      System.out.println("Some of the test cases had errors.");
    }
  }
  // END KAWIGIEDIT TESTING
}
// Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
